!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
App	traceConfig.h	/^struct App$/;"	s
BYTE_TO_BLOCK	simpleReplay.cpp	1698;"	d	file:
BasicApp	traceConfig.h	/^struct BasicApp$/;"	s
CJSON_VERSION_MAJOR	cJSON.h	32;"	d
CJSON_VERSION_MINOR	cJSON.h	33;"	d
CJSON_VERSION_PATCH	cJSON.h	34;"	d
CacheDirInfo	traceReplay.h	/^struct CacheDirInfo$/;"	s
CacheFileInfo	traceReplay.h	/^struct CacheFileInfo$/;"	s
CacheInfo	traceConfig.h	/^struct CacheInfo$/;"	s
CacheManager	traceReplay.h	/^struct CacheManager$/;"	s
CacheRef	traceReplay.h	/^struct CacheRef$/;"	s
CacheSize	traceReplay.h	/^struct CacheSize$/;"	s
Config	traceConfig.h	/^struct Config$/;"	s
DAYTIME	traceReplay.cpp	23;"	d	file:
DBInfo	dbReplay.h	/^struct DBInfo$/;"	s
DBManager	traceReplay.h	/^struct DBManager$/;"	s
DBTEMP	dbReplay.h	/^enum DBTEMP$/;"	g
DBTEMP_COLD	dbReplay.h	/^    DBTEMP_COLD = 2,$/;"	e	enum:DBTEMP
DBTEMP_HOT	dbReplay.h	/^    DBTEMP_HOT = 0,$/;"	e	enum:DBTEMP
DBTEMP_WARM	dbReplay.h	/^    DBTEMP_WARM = 1,$/;"	e	enum:DBTEMP
DBTYPE	dbReplay.h	/^enum DBTYPE$/;"	g
DBTYPE_DELETE	dbReplay.h	/^    DBTYPE_DELETE,$/;"	e	enum:DBTYPE
DBTYPE_FIXED	dbReplay.h	/^    DBTYPE_FIXED,$/;"	e	enum:DBTYPE
DBTYPE_INSERT	dbReplay.h	/^    DBTYPE_INSERT$/;"	e	enum:DBTYPE
DBTYPE_JOURNAL	dbReplay.h	/^    DBTYPE_JOURNAL,$/;"	e	enum:DBTYPE
DEBUG_REPLAY	simpleReplay.cpp	67;"	d	file:
DEFAULT_DAY	traceConfig.h	10;"	d
DYNAMIC_TEST	traceReplay.cpp	207;"	d	file:
DetachItemFromArray	cJSON.cpp	/^static cJSON *DetachItemFromArray(cJSON *array, size_t which)$/;"	f	file:
F2FS_IOC_SIMUL_TIME	traceReplay.cpp	355;"	d	file:
FI_RENAME	dbReplay.cpp	77;"	d	file:
FI_TRUNCATE	dbReplay.cpp	78;"	d	file:
FI_UNLINK	dbReplay.cpp	76;"	d	file:
FSYNCTIME	traceReplay.h	24;"	d
FullDisk	traceConfig.h	/^struct FullDisk$/;"	s
IG_curTime	traceReplay.cpp	/^double IG_curTime;$/;"	v
IG_lasttime	simpleReplay.cpp	/^double IG_lasttime;$/;"	v
IG_mode	traceReplay.cpp	/^int IG_mode;$/;"	v
IG_outPath	traceReplay.cpp	/^string IG_outPath;$/;"	v
IG_trace	simpleReplay.cpp	/^int IG_trace(string strLine)$/;"	f
INITFILE	traceReplay.h	20;"	d
INIT_FILEMAP	traceConfig.h	/^	char INIT_FILEMAP[PATH_MAX + 1];$/;"	m	struct:Config
INTEGER_SIZE	cJSON.cpp	38;"	d	file:
INTEGER_SIZE	cJSON.cpp	41;"	d	file:
INTEGER_SIZE	cJSON.cpp	44;"	d	file:
MAX_BLOCK	dbReplay.cpp	20;"	d	file:
MAX_FILE	dbReplay.cpp	21;"	d	file:
MAX_NAME	simpleReplay.cpp	18;"	d	file:
MAX_NAME	traceConfig.h	9;"	d
MAX_PATH	test.cpp	6;"	d	file:
MAX_SIZE	dbReplay.cpp	19;"	d	file:
MulConf	traceConfig.h	/^struct MulConf$/;"	s
MulDelete	traceConfig.h	/^struct MulDelete$/;"	s
Multimedia	traceConfig.h	/^struct Multimedia $/;"	s
NormalApp	traceConfig.h	/^struct NormalApp$/;"	s
PREV_OUT	traceReplay.h	21;"	d
PSName	traceConfig.h	/^struct PSName$/;"	s
REPLAY_BG	traceReplay.h	/^	REPLAY_BG$/;"	e	enum:REPLAY_TYPE
REPLAY_CAMERA	traceReplay.h	/^	REPLAY_CAMERA,$/;"	e	enum:REPLAY_TYPE
REPLAY_CAMERA_DELETE	traceReplay.h	/^	REPLAY_CAMERA_DELETE,$/;"	e	enum:REPLAY_TYPE
REPLAY_INSTALL	traceReplay.h	/^	REPLAY_INSTALL,$/;"	e	enum:REPLAY_TYPE
REPLAY_LOADING	traceReplay.h	/^	REPLAY_LOADING = 0,$/;"	e	enum:REPLAY_TYPE
REPLAY_MULTI	traceReplay.h	/^	REPLAY_MULTI,$/;"	e	enum:REPLAY_TYPE
REPLAY_MULTI_DELETE	traceReplay.h	/^	REPLAY_MULTI_DELETE,$/;"	e	enum:REPLAY_TYPE
REPLAY_TYPE	traceReplay.h	/^enum REPLAY_TYPE$/;"	g
REPLAY_UNINSTALL	traceReplay.h	/^	REPLAY_UNINSTALL,$/;"	e	enum:REPLAY_TYPE
REPLAY_UPDATE	traceReplay.h	/^	REPLAY_UPDATE,$/;"	e	enum:REPLAY_TYPE
REQ_APPEND	dbReplay.cpp	80;"	d	file:
REQ_UPDATE	dbReplay.cpp	81;"	d	file:
ReplaceItemInArray	cJSON.cpp	/^static void ReplaceItemInArray(cJSON *array, size_t which, cJSON *newitem)$/;"	f	file:
ReplayFile	traceReplay.h	/^struct ReplayFile$/;"	s
ReplayJob	traceReplay.h	/^struct ReplayJob$/;"	s
SPRINTF_INSTALL_PATH	dbReplay.cpp	72;"	d	file:
SPRINTF_INSTALL_PATH	traceReplay.h	13;"	d
SPRINTF_LOADING_PATH	dbReplay.cpp	66;"	d	file:
SPRINTF_LOADING_PATH	traceReplay.h	7;"	d
SPRINTF_LOADING_PATH_NUM	traceReplay.h	9;"	d
SPRINTF_TRACE_PATH_INPUT	traceConfig.cpp	626;"	d	file:
SPRINTF_TRACE_PATH_INPUT_NUM	traceConfig.cpp	630;"	d	file:
SPRINTF_TRACE_PATH_OUTPUT	traceConfig.cpp	628;"	d	file:
SPRINTF_TRACE_PATH_OUTPUT_NUM	traceConfig.cpp	632;"	d	file:
SPRINTF_TRACE_PATH_PREFIX	traceConfig.cpp	856;"	d	file:
SPRINTF_UNINSTALL_PATH	traceReplay.h	15;"	d
SPRINTF_UPDATE_PATH	dbReplay.cpp	69;"	d	file:
SPRINTF_UPDATE_PATH	traceReplay.h	11;"	d
SYSFS	traceReplay.h	23;"	d
TRACE_MERGE	traceReplay.h	19;"	d
TYPE_LINK	simpleReplay.cpp	290;"	d	file:
TYPE_REG	simpleReplay.cpp	289;"	d	file:
Traceinfo	traceConfig.cpp	/^struct Traceinfo$/;"	s	file:
VERBOSE	traceReplay.h	22;"	d
_GNU_SOURCE	cacheReplay.cpp	11;"	d	file:
_LARGEFILE64_SOURCE	cacheReplay.cpp	8;"	d	file:
_LARGEFILE_SOURCE	cacheReplay.cpp	2;"	d	file:
_SIMPLEREPLAY_H	simpleReplay.h	5;"	d
__USE_LARGEFILE64	cacheReplay.cpp	5;"	d	file:
__do_trace_replay	simpleReplay.cpp	/^static double __do_trace_replay(string strMount, char* line, struct ReplayJob *replay, double curTime, int isUpdate)$/;"	f	file:
access_avg_day	dbReplay.cpp	/^	int access_avg_day[MAX_FILE];$/;"	m	struct:stats_info	file:
access_cnt	dbReplay.cpp	/^    int access_cnt[MAX_SIZE];$/;"	m	struct:stats_info	file:
access_first	dbReplay.cpp	/^    int access_first[MAX_SIZE];$/;"	m	struct:stats_info	file:
analysis_database	dbReplay.cpp	/^void analysis_database(vector<struct DBInfo*> &DBvec, string app_path, string app_name, string app_ps, int total_loading_file)$/;"	f
app_count	traceConfig.h	/^	int app_count;$/;"	m	struct:BasicApp
app_count	traceConfig.h	/^	int app_count;$/;"	m	struct:NormalApp
app_install	traceReplay.cpp	/^int app_install(list<struct ReplayJob*> *jobqueue, list<struct App*> *ins_list, list<struct App*> *unins_list, $/;"	f
app_name	dbReplay.cpp	/^    string app_name;$/;"	m	struct:db_config	file:
app_path	dbReplay.cpp	/^    string app_path;$/;"	m	struct:db_config	file:
app_ps	dbReplay.cpp	/^    string app_ps;$/;"	m	struct:db_config	file:
apps	traceConfig.h	/^	struct App* apps;$/;"	m	struct:BasicApp	typeref:struct:BasicApp::App
apps	traceConfig.h	/^	struct App* apps;$/;"	m	struct:NormalApp	typeref:struct:NormalApp::App
backup_path	traceConfig.h	/^	char backup_path[PATH_MAX + 1];$/;"	m	struct:Config
basic_app	traceConfig.h	/^	struct BasicApp basic_app;$/;"	m	struct:Config	typeref:struct:Config::BasicApp
bg_cycle	traceConfig.h	/^	double bg_cycle;$/;"	m	struct:App
bg_file	traceConfig.h	/^	vector<string> bg_file;$/;"	m	struct:App
bgjob	traceReplay.h	/^	vector<string> bgjob;$/;"	m	struct:ReplayJob
block_type	dbReplay.h	/^	map<int, int> block_type;$/;"	m	struct:DBInfo
buffer	cJSON.cpp	/^    unsigned char *buffer;$/;"	m	struct:__anon1	file:
c	traceReplay.h	/^	int c;$/;"	m	struct:CacheDirInfo
cJSON	cJSON.h	/^typedef struct cJSON$/;"	s
cJSON	cJSON.h	/^} cJSON;$/;"	t	typeref:struct:cJSON
cJSON_AddBoolToObject	cJSON.h	166;"	d
cJSON_AddFalseToObject	cJSON.h	165;"	d
cJSON_AddItemReferenceToArray	cJSON.cpp	/^void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)$/;"	f
cJSON_AddItemReferenceToObject	cJSON.cpp	/^void cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)$/;"	f
cJSON_AddItemToArray	cJSON.cpp	/^void cJSON_AddItemToArray(cJSON *array, cJSON *item)$/;"	f
cJSON_AddItemToObject	cJSON.cpp	/^void   cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)$/;"	f
cJSON_AddItemToObjectCS	cJSON.cpp	/^void   cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)$/;"	f
cJSON_AddNullToObject	cJSON.h	163;"	d
cJSON_AddNumberToObject	cJSON.h	167;"	d
cJSON_AddRawToObject	cJSON.h	169;"	d
cJSON_AddStringToObject	cJSON.h	168;"	d
cJSON_AddTrueToObject	cJSON.h	164;"	d
cJSON_Array	cJSON.h	47;"	d
cJSON_ArrayForEach	cJSON.h	178;"	d
cJSON_CreateArray	cJSON.cpp	/^cJSON *cJSON_CreateArray(void)$/;"	f
cJSON_CreateBool	cJSON.cpp	/^cJSON *cJSON_CreateBool(cjbool b)$/;"	f
cJSON_CreateDoubleArray	cJSON.cpp	/^cJSON *cJSON_CreateDoubleArray(const double *numbers, int count)$/;"	f
cJSON_CreateFalse	cJSON.cpp	/^cJSON *cJSON_CreateFalse(void)$/;"	f
cJSON_CreateFloatArray	cJSON.cpp	/^cJSON *cJSON_CreateFloatArray(const float *numbers, int count)$/;"	f
cJSON_CreateIntArray	cJSON.cpp	/^cJSON *cJSON_CreateIntArray(const int *numbers, int count)$/;"	f
cJSON_CreateNull	cJSON.cpp	/^cJSON *cJSON_CreateNull(void)$/;"	f
cJSON_CreateNumber	cJSON.cpp	/^cJSON *cJSON_CreateNumber(double num)$/;"	f
cJSON_CreateObject	cJSON.cpp	/^cJSON *cJSON_CreateObject(void)$/;"	f
cJSON_CreateRaw	cJSON.cpp	/^extern cJSON *cJSON_CreateRaw(const char *raw)$/;"	f
cJSON_CreateString	cJSON.cpp	/^cJSON *cJSON_CreateString(const char *string)$/;"	f
cJSON_CreateStringArray	cJSON.cpp	/^cJSON *cJSON_CreateStringArray(const char **strings, int count)$/;"	f
cJSON_CreateTrue	cJSON.cpp	/^cJSON *cJSON_CreateTrue(void)$/;"	f
cJSON_Delete	cJSON.cpp	/^void cJSON_Delete(cJSON *c)$/;"	f
cJSON_DeleteItemFromArray	cJSON.cpp	/^void cJSON_DeleteItemFromArray(cJSON *array, int which)$/;"	f
cJSON_DeleteItemFromObject	cJSON.cpp	/^void cJSON_DeleteItemFromObject(cJSON *object, const char *string)$/;"	f
cJSON_DetachItemFromArray	cJSON.cpp	/^cJSON *cJSON_DetachItemFromArray(cJSON *array, int which)$/;"	f
cJSON_DetachItemFromObject	cJSON.cpp	/^cJSON *cJSON_DetachItemFromObject(cJSON *object, const char *string)$/;"	f
cJSON_Duplicate	cJSON.cpp	/^cJSON *cJSON_Duplicate(const cJSON *item, cjbool recurse)$/;"	f
cJSON_False	cJSON.h	42;"	d
cJSON_GetArrayItem	cJSON.cpp	/^cJSON *cJSON_GetArrayItem(const cJSON *array, int item)$/;"	f
cJSON_GetArraySize	cJSON.cpp	/^int cJSON_GetArraySize(const cJSON *array)$/;"	f
cJSON_GetErrorPtr	cJSON.cpp	/^const char *cJSON_GetErrorPtr(void)$/;"	f
cJSON_GetObjectItem	cJSON.cpp	/^cJSON *cJSON_GetObjectItem(const cJSON *object, const char *string)$/;"	f
cJSON_HasObjectItem	cJSON.cpp	/^cjbool cJSON_HasObjectItem(const cJSON *object, const char *string)$/;"	f
cJSON_Hooks	cJSON.h	/^typedef struct cJSON_Hooks$/;"	s
cJSON_Hooks	cJSON.h	/^} cJSON_Hooks;$/;"	t	typeref:struct:cJSON_Hooks
cJSON_InitHooks	cJSON.cpp	/^void cJSON_InitHooks(cJSON_Hooks* hooks)$/;"	f
cJSON_InsertItemInArray	cJSON.cpp	/^void cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)$/;"	f
cJSON_IsReference	cJSON.h	51;"	d
cJSON_Minify	cJSON.cpp	/^void cJSON_Minify(char *json)$/;"	f
cJSON_NULL	cJSON.h	44;"	d
cJSON_New_Item	cJSON.cpp	/^static cJSON *cJSON_New_Item(void)$/;"	f	file:
cJSON_Number	cJSON.h	45;"	d
cJSON_Object	cJSON.h	48;"	d
cJSON_Parse	cJSON.cpp	/^cJSON *cJSON_Parse(const char *value)$/;"	f
cJSON_ParseWithOpts	cJSON.cpp	/^cJSON *cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cjbool require_null_terminated)$/;"	f
cJSON_Print	cJSON.cpp	/^char *cJSON_Print(const cJSON *item)$/;"	f
cJSON_PrintBuffered	cJSON.cpp	/^char *cJSON_PrintBuffered(const cJSON *item, int prebuffer, cjbool fmt)$/;"	f
cJSON_PrintPreallocated	cJSON.cpp	/^int cJSON_PrintPreallocated(cJSON *item, char *buf, const int len, const cjbool fmt)$/;"	f
cJSON_PrintUnformatted	cJSON.cpp	/^char *cJSON_PrintUnformatted(const cJSON *item)$/;"	f
cJSON_Raw	cJSON.h	49;"	d
cJSON_ReplaceItemInArray	cJSON.cpp	/^void cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)$/;"	f
cJSON_ReplaceItemInObject	cJSON.cpp	/^void cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)$/;"	f
cJSON_SetIntValue	cJSON.h	172;"	d
cJSON_SetNumberHelper	cJSON.cpp	/^double cJSON_SetNumberHelper(cJSON *object, double number)$/;"	f
cJSON_SetNumberValue	cJSON.h	175;"	d
cJSON_String	cJSON.h	46;"	d
cJSON_StringIsConst	cJSON.h	52;"	d
cJSON_True	cJSON.h	43;"	d
cJSON_Version	cJSON.cpp	/^extern const char* cJSON_Version(void)$/;"	f
cJSON__h	cJSON.h	24;"	d
cJSON_free	cJSON.cpp	/^static void (*cJSON_free)(void *ptr) = free;$/;"	v	file:
cJSON_malloc	cJSON.cpp	/^static void *(*cJSON_malloc)(size_t sz) = malloc;$/;"	v	file:
cJSON_strcasecmp	cJSON.cpp	/^static int cJSON_strcasecmp(const unsigned char *s1, const unsigned char *s2)$/;"	f	file:
cJSON_strdup	cJSON.cpp	/^static unsigned char* cJSON_strdup(const unsigned char* str)$/;"	f	file:
cache	traceReplay.h	/^	struct CacheManager cache;$/;"	m	struct:ReplayJob	typeref:struct:ReplayJob::CacheManager
cache_info	traceConfig.h	/^	vector<CacheInfo> cache_info;$/;"	m	struct:App
cache_list	traceReplay.h	/^	vector<struct CacheDirInfo> cache_list;$/;"	m	struct:CacheManager
cacheref	traceReplay.h	/^	struct CacheRef cacheref;$/;"	m	struct:CacheDirInfo	typeref:struct:CacheDirInfo::CacheRef
calc_c	cacheReplay.cpp	/^double calc_c(int max_ref)$/;"	f
camera_create	traceReplay.cpp	/^	int camera_create;$/;"	m	struct:replay_stat	file:
camera_delete	traceConfig.h	/^	int camera_delete;$/;"	m	struct:FullDisk
camera_delete	traceReplay.cpp	/^	int camera_delete;$/;"	m	struct:replay_stat	file:
check_access_cache	simpleReplay.cpp	/^static struct CacheFileInfo* check_access_cache(struct CacheDirInfo* cacheDirInfo)$/;"	f	file:
child	cJSON.h	/^    struct cJSON *child;$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON
cjbool	cJSON.cpp	/^typedef int cjbool;$/;"	t	file:
cold_brate	dbReplay.h	/^	int cold_brate;	\/\/ [0-100]$/;"	m	struct:DBInfo
config	traceReplay.cpp	/^struct Config *config;$/;"	v	typeref:struct:Config
create	simpleReplay.cpp	/^	int create;$/;"	m	struct:trace_stat	file:
create_bgjob	traceReplay.cpp	/^struct ReplayJob* create_bgjob(struct App* app)$/;"	f
create_cache_file	simpleReplay.cpp	/^static int create_cache_file(struct ReplayJob *arg_replay, string path)$/;"	f	file:
create_camera_file	simpleReplay.cpp	/^int create_camera_file(char *mount_dir, char* camera_path, char* ext_path, unsigned long long size)$/;"	f
create_camera_file	simpleReplay.cpp	/^int create_camera_file(char* camera_path, unsigned long long size)$/;"	f
create_init_files	simpleReplay.cpp	/^int create_init_files(FILE* init_fp)$/;"	f
create_init_files	simpleReplay.cpp	/^int create_init_files(char* mount_dir, char* init_name)$/;"	f
create_reference	cJSON.cpp	/^static cJSON *create_reference(const cJSON *item)$/;"	f	file:
create_replayjob	traceReplay.cpp	/^struct ReplayJob* create_replayjob(enum REPLAY_TYPE type, const char *name, const char *path, double cycle)$/;"	f
create_replayjob	traceReplay.cpp	/^struct ReplayJob* create_replayjob(enum REPLAY_TYPE type, struct ReplayJob *replay)$/;"	f
curLoading	traceReplay.h	/^	int curLoading;$/;"	m	struct:ReplayJob
curTime	traceReplay.h	/^	double curTime;$/;"	m	struct:ReplayFile
curTime	traceReplay.h	/^	double curTime;$/;"	m	struct:ReplayJob
cur_cache_size	traceReplay.h	/^	long long cur_cache_size;$/;"	m	struct:CacheDirInfo
cur_file_size	dbReplay.cpp	/^    long long int cur_file_size;$/;"	m	struct:stats_info	file:
cur_time	dbReplay.cpp	/^double cur_time = 0.0;$/;"	v
cycle	traceReplay.h	/^	double cycle;$/;"	m	struct:ReplayJob
database_append	simpleReplay.cpp	/^static int database_append(struct ReplayJob *replay, string trace_path, long long int write_off, long long int write_size, long long int file_size)$/;"	f	file:
database_overwrite	simpleReplay.cpp	/^static int database_overwrite(struct ReplayJob *replay, string trace_path, long long int write_off, long long int write_size, long long int file_size)$/;"	f	file:
database_truncate	simpleReplay.cpp	/^static int database_truncate(struct ReplayJob *replay, string trace_path, long long int after_size, long long int before_size)$/;"	f	file:
database_unlink	simpleReplay.cpp	/^static int database_unlink(struct ReplayJob *replay, string trace_path)$/;"	f	file:
db	traceReplay.h	/^	struct DBManager db;$/;"	m	struct:ReplayJob	typeref:struct:ReplayJob::DBManager
db_config	dbReplay.cpp	/^struct db_config$/;"	s	file:
db_map	traceReplay.h	/^	map<string, struct DBInfo*> db_map;$/;"	m	struct:DBManager
dbconfig	dbReplay.cpp	/^struct db_config dbconfig;$/;"	v	typeref:struct:db_config
dbtype_to_string	traceReplay.cpp	/^string dbtype_to_string(enum DBTYPE type)$/;"	f
default_bg_cycle	traceConfig.h	/^	double default_bg_cycle;$/;"	m	struct:BasicApp
default_bg_cycle	traceConfig.h	/^	double default_bg_cycle;$/;"	m	struct:NormalApp
default_loading_cycle	traceConfig.h	/^	double default_loading_cycle;$/;"	m	struct:BasicApp
default_loading_cycle	traceConfig.h	/^	double default_loading_cycle;$/;"	m	struct:NormalApp
default_update_cycle	traceConfig.h	/^	double default_update_cycle;$/;"	m	struct:BasicApp
default_update_cycle	traceConfig.h	/^	double default_update_cycle;$/;"	m	struct:NormalApp
delete_camera_file	simpleReplay.cpp	/^int delete_camera_file(char* camera_path)$/;"	f
delete_camera_file	simpleReplay.cpp	/^int delete_camera_file(char* mount_dir, char* camera_path)$/;"	f
delete_count	traceConfig.h	/^	int delete_count;$/;"	m	struct:MulConf
dirty_DB	dbReplay.cpp	/^map<string, struct dirty_info*> dirty_DB;$/;"	v
dirty_info	dbReplay.cpp	/^struct dirty_info$/;"	s	file:
do_fulldisk	traceReplay.cpp	/^static int do_fulldisk(list <struct ReplayJob*> *queue, list<struct App*> *ins_list, $/;"	f	file:
do_set_background_map	traceConfig.cpp	/^static int do_set_background_map(struct Config *config, char *file, struct App *cur_app)$/;"	f	file:
do_trace_merge	traceConfig.cpp	/^static int do_trace_merge(struct App *app, struct PSName *ps_name, string type, int num)$/;"	f	file:
do_trace_replay	simpleReplay.cpp	/^double do_trace_replay(char* mount_dir, char *input_name, struct ReplayJob *replay, double curTime, char* name)$/;"	f
do_trace_replay	simpleReplay.cpp	/^double do_trace_replay(struct ReplayFile *load_replay, list<struct ReplayFile> *update_list, char* name)$/;"	f
do_trace_replay	traceReplay.cpp	/^int do_trace_replay(double day)$/;"	f
do_update_stats_DB_for_file	dbReplay.cpp	/^static int do_update_stats_DB_for_file(struct dirty_info* dirty)$/;"	f	file:
ensure	cJSON.cpp	/^static unsigned char* ensure(printbuffer *p, size_t needed)$/;"	f	file:
evict_cache_files	simpleReplay.cpp	/^static void evict_cache_files(struct CacheDirInfo *cacheDirInfo)$/;"	f	file:
evict_ratio	traceConfig.h	/^	double evict_ratio;$/;"	m	struct:CacheInfo
evict_ratio	traceReplay.h	/^	double evict_ratio;$/;"	m	struct:CacheDirInfo
false	cJSON.cpp	52;"	d	file:
fileID	traceReplay.h	/^	int fileID;$/;"	m	struct:CacheFileInfo
file_DB	dbReplay.cpp	/^map<string, double> file_DB;$/;"	v
file_append	simpleReplay.cpp	/^int file_append(const char *path, long long int write_off, $/;"	f
file_create	simpleReplay.cpp	/^int file_create(const char *path)$/;"	f
file_fsync	simpleReplay.cpp	/^int file_fsync(char *path, int option)$/;"	f
file_map	traceReplay.h	/^	map<string, string> file_map;		\/\/ trace_path, new_path$/;"	m	struct:CacheDirInfo
file_mkdir	simpleReplay.cpp	/^int file_mkdir(char *path)$/;"	f
file_read	simpleReplay.cpp	/^int file_read(char *path, long long int read_off, long long int read_size, char *name)$/;"	f
file_rename	simpleReplay.cpp	/^int file_rename(char *path1, char *path2)$/;"	f
file_rmap	traceReplay.h	/^	map<string, string> file_rmap;		\/\/ new_path, trace_path$/;"	m	struct:CacheDirInfo
file_rmdir	simpleReplay.cpp	/^int file_rmdir(char *path)$/;"	f
file_size	dbReplay.cpp	/^    long long int file_size;$/;"	m	struct:dirty_info	file:
file_smap	traceReplay.h	/^	map<string, unsigned long long> file_smap;	\/\/ new_path, file_size;$/;"	m	struct:CacheDirInfo
file_truncate	simpleReplay.cpp	/^int file_truncate(const char *path,$/;"	f
file_truncate_same	simpleReplay.cpp	/^int file_truncate_same(const char *path,$/;"	f
file_unlink	simpleReplay.cpp	/^int file_unlink(char *path)$/;"	f
file_write	simpleReplay.cpp	/^int file_write(const char *path, long long int write_off, $/;"	f
filelist	traceReplay.h	/^	list<CacheFileInfo*> filelist;$/;"	m	struct:CacheRef
filename	traceConfig.cpp	/^	string filename;$/;"	m	struct:Traceinfo	file:
filesize	traceReplay.h	/^	long long int filesize;$/;"	m	struct:CacheFileInfo
filesize	traceReplay.h	/^	long long int filesize;$/;"	m	struct:CacheSize
firstByteMark	cJSON.cpp	/^static const unsigned char firstByteMark[5] =$/;"	v	file:
fp	traceConfig.cpp	/^	FILE *fp;$/;"	m	struct:Traceinfo	file:
free_fn	cJSON.h	/^      void (*free_fn)(void *ptr);$/;"	m	struct:cJSON_Hooks
fsync	simpleReplay.cpp	/^	int fsync;$/;"	m	struct:trace_stat	file:
fulldisk	traceConfig.h	/^	struct FullDisk fulldisk;$/;"	m	struct:Config	typeref:struct:Config::FullDisk
g_cur_seq	dbReplay.cpp	/^int g_cur_seq = 1;$/;"	v
get_cache_info	simpleReplay.cpp	/^static struct CacheDirInfo* get_cache_info(struct ReplayJob *replay, string path)$/;"	f	file:
get_clear_path	simpleReplay.cpp	/^static string get_clear_path(string trace_path) $/;"	f	file:
get_clear_path	traceReplay.cpp	/^static string get_clear_path(string trace_path)$/;"	f	file:
get_dir_path	simpleReplay.cpp	/^static string get_dir_path(string full_path)$/;"	f	file:
get_extension	simpleReplay.cpp	/^int get_extension(string path, string *ext)$/;"	f
get_file_size	simpleReplay.cpp	/^long long int get_file_size(string path)$/;"	f
get_mount_point	traceReplay.cpp	/^static struct mntent *get_mount_point(const char *name)$/;"	f	file:
get_time	simpleReplay.cpp	/^static double get_time(char *line)$/;"	f	file:
get_utilization	traceReplay.cpp	/^static double get_utilization(void)$/;"	f	file:
global_ep	cJSON.cpp	/^static const unsigned char *global_ep = NULL;$/;"	v	file:
hot_brate	dbReplay.h	/^	int hot_brate;	\/\/ [0-100]$/;"	m	struct:DBInfo
hot_list	dbReplay.h	/^	vector<int> hot_list;$/;"	m	struct:DBInfo
hot_wrate	dbReplay.h	/^	int hot_wrate; \/\/ [0-100]$/;"	m	struct:DBInfo
idcount	traceReplay.h	/^	int idcount;$/;"	m	struct:CacheDirInfo
init_cache	simpleReplay.cpp	/^int init_cache(char* mount_dir, const char *prefix, struct CacheDirInfo *cacheDirInfo)$/;"	f
init_cache_file	simpleReplay.cpp	/^static int init_cache_file(struct CacheDirInfo *cacheDirInfo, string trace_path, unsigned long long int size)$/;"	f	file:
init_count	traceConfig.h	/^	int init_count;$/;"	m	struct:MulConf
init_db_manager	traceReplay.cpp	/^static void init_db_manager(struct ReplayJob *replay_loading, char *mount_dir, string app_name, string app_path, string app_ps, int total_file)$/;"	f	file:
init_info	dbReplay.cpp	/^static int init_info(struct stats_info *info, string path)$/;"	f	file:
init_replayjob	traceReplay.cpp	/^int init_replayjob(list<struct ReplayJob*> *ReplayJob_queue, list<struct App*> *Normal_list)$/;"	f
input_name	traceReplay.h	/^	string input_name;$/;"	m	struct:ReplayFile
insert_recent_cache	simpleReplay.cpp	/^static int insert_recent_cache(struct CacheDirInfo *cacheDirInfo, string trace_path)$/;"	f	file:
insert_replayqueue	traceReplay.cpp	/^int insert_replayqueue(list<struct ReplayJob*> *ReplayJob_queue, struct ReplayJob* job)$/;"	f
install	traceReplay.cpp	/^	int install;$/;"	m	struct:replay_stat	file:
install_cycle	traceConfig.h	/^	double install_cycle;$/;"	m	struct:NormalApp
install_file_size	dbReplay.cpp	/^    int install_file_size;$/;"	m	struct:stats_info	file:
job	traceReplay.h	/^	struct ReplayJob *job;$/;"	m	struct:ReplayFile	typeref:struct:ReplayFile::ReplayJob
length	cJSON.cpp	/^    size_t length;$/;"	m	struct:__anon1	file:
limit	traceConfig.h	/^	double limit;$/;"	m	struct:FullDisk
limit_size	dbReplay.h	/^	int limit_size; \/\/ filesize * 10;$/;"	m	struct:DBInfo
line	traceConfig.cpp	/^	string line;$/;"	m	struct:Traceinfo	file:
loadJob	traceReplay.h	/^	struct ReplayJob* loadJob;$/;"	m	struct:ReplayJob	typeref:struct:ReplayJob::ReplayJob
load_replayjob	traceReplay.cpp	/^int load_replayjob(list <struct ReplayJob*> *ReplayJob_queue, list<struct App*> *ins_list, list<struct App*> *unins_list, double *day)$/;"	f
loading	traceReplay.cpp	/^	int loading;$/;"	m	struct:replay_stat	file:
loading_cycle	traceConfig.h	/^	double loading_cycle;$/;"	m	struct:App
loading_file	traceConfig.h	/^	int loading_file;$/;"	m	struct:App
lru_list	traceReplay.h	/^	list<string> lru_list;$/;"	m	struct:CacheDirInfo
main	norm_random.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test.c	/^int main()$/;"	f
main	test.cpp	/^int main(void)$/;"	f
main	traceReplay.cpp	/^int main (int argc, char *argv[])$/;"	f
malloc_fn	cJSON.h	/^      void *(*malloc_fn)(size_t sz);$/;"	m	struct:cJSON_Hooks
maxLoading	traceReplay.h	/^	int maxLoading;$/;"	m	struct:ReplayJob
max_cache_size	traceConfig.h	/^	double max_cache_size;$/;"	m	struct:CacheInfo
max_cache_size	traceReplay.h	/^	long long max_cache_size;$/;"	m	struct:CacheDirInfo
max_file_size	dbReplay.cpp	/^    int max_file_size;$/;"	m	struct:stats_info	file:
max_ref	traceConfig.h	/^	int max_ref;$/;"	m	struct:CacheInfo
max_ref	traceReplay.h	/^	int max_ref;$/;"	m	struct:CacheDirInfo
max_size	traceConfig.h	/^	unsigned long long max_size;$/;"	m	struct:MulConf
meta_offset	dbReplay.h	/^	int meta_offset;$/;"	m	struct:DBInfo
min_size	traceConfig.h	/^	unsigned long long min_size;$/;"	m	struct:MulConf
mkdir	simpleReplay.cpp	/^	int mkdir;$/;"	m	struct:trace_stat	file:
mkdir_all_path	simpleReplay.cpp	/^int mkdir_all_path(const char *path)$/;"	f
mode_flag	traceReplay.cpp	/^int mode_flag;$/;"	v
mount_dir	traceConfig.h	/^	char mount_dir[PATH_MAX + 1];$/;"	m	struct:Config
mount_dir	traceReplay.h	/^	string mount_dir;$/;"	m	struct:ReplayFile
mul_camera	traceConfig.h	/^	struct MulConf mul_camera;$/;"	m	struct:Multimedia	typeref:struct:Multimedia::MulConf
mul_delete	traceConfig.h	/^	int mul_delete;$/;"	m	struct:MulDelete
mul_delete	traceConfig.h	/^	vector<struct MulDelete> mul_delete;	$/;"	m	struct:FullDisk
mul_info	traceReplay.h	/^	unsigned long long mul_info[2];$/;"	m	struct:ReplayJob
mul_others	traceConfig.h	/^	vector<struct MulConf> mul_others;$/;"	m	struct:Multimedia
multi	traceConfig.h	/^	struct Multimedia multi;$/;"	m	struct:Config	typeref:struct:Config::Multimedia
multimedia_path	traceConfig.h	/^	string multimedia_path;$/;"	m	struct:MulConf
name	traceConfig.h	/^	char name[MAX_NAME];$/;"	m	struct:App
name	traceConfig.h	/^	string name;$/;"	m	struct:MulConf
name	traceConfig.h	/^	string name;$/;"	m	struct:MulDelete
name	traceReplay.h	/^	char name[MAX_NAME];$/;"	m	struct:ReplayJob
next	cJSON.h	/^    struct cJSON *next;$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON
noalloc	cJSON.cpp	/^    cjbool noalloc;$/;"	m	struct:__anon1	file:
normal_app	traceConfig.h	/^	struct NormalApp normal_app;$/;"	m	struct:Config	typeref:struct:Config::NormalApp
off	dbReplay.cpp	/^    long long int off;$/;"	m	struct:dirty_info	file:
offset	cJSON.cpp	/^    size_t offset;$/;"	m	struct:__anon1	file:
onetimes_ratio	traceConfig.h	/^	double onetimes_ratio;$/;"	m	struct:CacheInfo
onetimes_ratio	traceReplay.h	/^	double onetimes_ratio;$/;"	m	struct:CacheDirInfo
parse_apps	traceConfig.cpp	/^static int parse_apps(cJSON *apps_obj, struct App *apps, $/;"	f	file:
parse_array	cJSON.cpp	/^static const unsigned char *parse_array(cJSON *item, const unsigned char *value, const unsigned char **ep)$/;"	f	file:
parse_basic_app	traceConfig.cpp	/^static int parse_basic_app(cJSON *basic_obj, struct Config *config)$/;"	f	file:
parse_config	traceConfig.cpp	/^int parse_config(char *config_name, struct Config *config)$/;"	f
parse_fulldisk	traceConfig.cpp	/^static int parse_fulldisk(cJSON *ps_full_obj, struct Config *config)$/;"	f	file:
parse_hex4	cJSON.cpp	/^static unsigned parse_hex4(const unsigned char *str)$/;"	f	file:
parse_multimedia	traceConfig.cpp	/^static int parse_multimedia(cJSON *multi_obj, struct Config *config)$/;"	f	file:
parse_normal_app	traceConfig.cpp	/^static int parse_normal_app(cJSON *normal_obj, struct Config *config)$/;"	f	file:
parse_number	cJSON.cpp	/^static const unsigned char *parse_number(cJSON *item, const unsigned char *num)$/;"	f	file:
parse_object	cJSON.cpp	/^static const unsigned char *parse_object(cJSON *item, const unsigned char *value, const unsigned char **ep)$/;"	f	file:
parse_ps_name	traceConfig.cpp	/^static int parse_ps_name(cJSON *ps_name_obj, struct Config *config)$/;"	f	file:
parse_string	cJSON.cpp	/^static const unsigned char *parse_string(cJSON *item, const unsigned char *str, const unsigned char **ep)$/;"	f	file:
parse_time	traceConfig.cpp	/^static double parse_time(string line)$/;"	f	file:
parse_value	cJSON.cpp	/^static const unsigned  char *parse_value(cJSON *item, const unsigned char *value, const unsigned char **ep)$/;"	f	file:
path	dbReplay.cpp	/^    string path;$/;"	m	struct:dirty_info	file:
path	dbReplay.cpp	/^    string path;$/;"	m	struct:stats_info	file:
path	dbReplay.h	/^	string path;$/;"	m	struct:DBInfo
path	traceConfig.h	/^	char path[PATH_MAX+1];$/;"	m	struct:App
path	traceConfig.h	/^	string path;$/;"	m	struct:CacheInfo
path	traceConfig.h	/^	string path;$/;"	m	struct:MulDelete
path	traceReplay.h	/^	char path[PATH_MAX + 1];$/;"	m	struct:ReplayJob
path	traceReplay.h	/^	string path;$/;"	m	struct:CacheDirInfo
path	traceReplay.h	/^	string path;$/;"	m	struct:CacheSize
pop_update	simpleReplay.cpp	/^static FILE* pop_update(struct ReplayFile *load_replay, list<struct ReplayFile> *update_list)$/;"	f	file:
pow2gt	cJSON.cpp	/^static int pow2gt (int x)$/;"	f	file:
prev	cJSON.h	/^    struct cJSON *prev;$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON
prev_out_name	traceReplay.cpp	/^string prev_out_name;$/;"	v
print_array	cJSON.cpp	/^static unsigned char *print_array(const cJSON *item, size_t depth, cjbool fmt, printbuffer *p)$/;"	f	file:
print_help	traceReplay.cpp	/^int print_help(void)$/;"	f
print_number	cJSON.cpp	/^static unsigned char *print_number(const cJSON *item, printbuffer *p)$/;"	f	file:
print_object	cJSON.cpp	/^static unsigned char *print_object(const cJSON *item, size_t depth, cjbool fmt, printbuffer *p)$/;"	f	file:
print_starttrace_fsync	simpleReplay.cpp	/^int print_starttrace_fsync(double curTime)$/;"	f
print_string	cJSON.cpp	/^static unsigned char *print_string(const cJSON *item, printbuffer *p)$/;"	f	file:
print_string_ptr	cJSON.cpp	/^static unsigned char *print_string_ptr(const unsigned char *str, printbuffer *p)$/;"	f	file:
print_time_fsync	simpleReplay.cpp	/^int print_time_fsync(clock_t start_time, clock_t end_time)$/;"	f
print_time_read	simpleReplay.cpp	/^int print_time_read(char* name, clock_t start_time, clock_t end_time) \/\/ update$/;"	f
print_value	cJSON.cpp	/^static unsigned char *print_value(const cJSON *item, size_t depth, cjbool fmt, printbuffer *p)$/;"	f	file:
printbuffer	cJSON.cpp	/^} printbuffer;$/;"	t	typeref:struct:__anon1	file:
ps_install	traceConfig.h	/^	vector<string> ps_install;$/;"	m	struct:PSName
ps_loading	traceConfig.h	/^	vector<string> ps_loading;$/;"	m	struct:PSName
ps_name	traceConfig.h	/^	char ps_name[MAX_NAME];$/;"	m	struct:App
ps_name	traceConfig.h	/^	struct PSName ps_name;$/;"	m	struct:Config	typeref:struct:Config::PSName
ps_uninstall	traceConfig.h	/^	vector<string> ps_uninstall;$/;"	m	struct:PSName
ps_update	traceConfig.h	/^	vector<string> ps_update;$/;"	m	struct:PSName
rand_val	cacheReplay.cpp	/^double rand_val(void)$/;"	f
randn	norm_random.cpp	/^randn (double mu, double sigma)$/;"	f
randn	traceReplay.cpp	/^double randn (double mu, double sigma)$/;"	f
recent_cache	traceReplay.h	/^	list<CacheSize> recent_cache;$/;"	m	struct:CacheDirInfo
ref	traceReplay.h	/^	int ref;$/;"	m	struct:CacheFileInfo
remove_dir_caches	simpleReplay.cpp	/^static void remove_dir_caches(struct ReplayJob *arg_replay, string trace_path)$/;"	f	file:
remove_directory	simpleReplay.cpp	/^int remove_directory(const char *path)$/;"	f
rename	simpleReplay.cpp	/^	int rename;$/;"	m	struct:trace_stat	file:
rename_DB	dbReplay.cpp	/^map<string, struct stats_info*> rename_DB;$/;"	v
replay_basic_install	traceReplay.cpp	/^int replay_basic_install(void)$/;"	f
replay_bg	traceReplay.cpp	/^int replay_bg(struct ReplayJob* replay)$/;"	f
replay_bg	traceReplay.cpp	/^int replay_bg(struct ReplayJob* replay, list<struct ReplayFile> *update_list)$/;"	f
replay_camera	traceReplay.cpp	/^int replay_camera(struct ReplayJob* replay)$/;"	f
replay_camera_delete	traceReplay.cpp	/^int replay_camera_delete(struct ReplayJob* replay)$/;"	f
replay_init_multimedia	traceReplay.cpp	/^int replay_init_multimedia(void)$/;"	f
replay_install	traceReplay.cpp	/^int replay_install(list<struct ReplayJob*> *jobqueue, list<struct App*> *ins_list, list<struct App*> *unins_list, double curTime)$/;"	f
replay_loading	traceReplay.cpp	/^int replay_loading(struct ReplayJob* replay, char *name)$/;"	f
replay_loading	traceReplay.cpp	/^int replay_loading(struct ReplayJob* replay, list<struct ReplayFile> *update_list, $/;"	f
replay_stat	traceReplay.cpp	/^struct replay_stat replay_stat;$/;"	v	typeref:struct:replay_stat
replay_stat	traceReplay.cpp	/^struct replay_stat$/;"	s	file:
replay_uninstall	traceReplay.cpp	/^int replay_uninstall(list<struct ReplayJob*> *jobqueue, list<struct App*> *ins_list, list<struct App*> *unins_list, double curTime)$/;"	f
replay_update	traceReplay.cpp	/^int replay_update(struct ReplayJob* replay)$/;"	f
replay_update	traceReplay.cpp	/^int replay_update(struct ReplayJob* replay, list<struct ReplayFile> *update_list)$/;"	f
req_type	dbReplay.cpp	/^    int req_type;$/;"	m	struct:dirty_info	file:
request	dbReplay.cpp	/^struct request$/;"	s	file:
reset_file_DB	dbReplay.cpp	/^static int reset_file_DB(void)$/;"	f	file:
rmdir	simpleReplay.cpp	/^	int rmdir;$/;"	m	struct:trace_stat	file:
search_cache_file	simpleReplay.cpp	/^static int search_cache_file(struct ReplayJob *arg_replay, string trace_path, string *new_path)$/;"	f	file:
search_db_info	simpleReplay.cpp	/^static struct DBInfo* search_db_info(struct ReplayJob *arg_replay, string trace_path)$/;"	f	file:
search_db_type	simpleReplay.cpp	/^static int search_db_type(struct ReplayJob *arg_replay, string trace_path)$/;"	f	file:
search_recent_cache	simpleReplay.cpp	/^static int search_recent_cache(struct CacheDirInfo *cacheDirInfo, string trace_path)$/;"	f	file:
select_filesize	cacheReplay.cpp	/^int select_filesize(vector<long long int> *sizevec)$/;"	f
select_ref	cacheReplay.cpp	/^int select_ref(double onetimes, double c, double zipf_slope, int max_ref)$/;"	f
select_unique	cacheReplay.cpp	/^int select_unique(double unique)$/;"	f
set_background_map	traceConfig.cpp	/^int set_background_map(struct Config *config)$/;"	f
size	dbReplay.cpp	/^    int size;$/;"	m	struct:request	file:
size	dbReplay.cpp	/^    long long int size;$/;"	m	struct:dirty_info	file:
sizevec	traceReplay.h	/^	vector<long long int> sizevec;$/;"	m	struct:CacheDirInfo
skip	cJSON.cpp	/^static const unsigned char *skip(const unsigned char *in)$/;"	f	file:
start	dbReplay.cpp	/^    int start;$/;"	m	struct:request	file:
stats_info	dbReplay.cpp	/^struct stats_info$/;"	s	file:
store_replayjob	traceReplay.cpp	/^int store_replayjob(list <struct ReplayJob*> *ReplayJob_queue, list<struct App*> *ins_list, double day)$/;"	f
string	cJSON.h	/^    char *string;$/;"	m	struct:cJSON
suffix_object	cJSON.cpp	/^static void suffix_object(cJSON *prev, cJSON *item)$/;"	f	file:
sum_access_avg	dbReplay.cpp	/^	int sum_access_avg;$/;"	m	struct:stats_info	file:
take_count	traceConfig.h	/^	int take_count;$/;"	m	struct:MulConf
test_and_create_cache	simpleReplay.cpp	/^static int test_and_create_cache(struct ReplayJob *arg_replay, string trace_path, long long int file_size)$/;"	f	file:
test_cache	simpleReplay.cpp	/^static int test_cache(struct ReplayJob *arg_replay, string trace_path)$/;"	f	file:
time	traceConfig.cpp	/^	double time;$/;"	m	struct:Traceinfo	file:
total_ref	traceReplay.h	/^	int total_ref;$/;"	m	struct:CacheRef
tr_after_size	dbReplay.cpp	/^    int tr_after_size;$/;"	m	struct:stats_info	file:
tr_count	dbReplay.cpp	/^    int tr_count;$/;"	m	struct:stats_info	file:
trace_analysis	dbReplay.cpp	/^static double trace_analysis(char *input_name)$/;"	f	file:
trace_init	traceReplay.cpp	/^int trace_init(void)$/;"	f
trace_merge	traceConfig.cpp	/^int trace_merge(struct Config *config)$/;"	f
trace_replay	simpleReplay.cpp	/^double trace_replay(char *input_name)$/;"	f
trace_replay	traceReplay.cpp	/^static int trace_replay(char *config_name, int day)$/;"	f	file:
trace_stat	simpleReplay.cpp	/^struct trace_stat$/;"	s	file:
true	cJSON.cpp	51;"	d	file:
try_reuse	cacheReplay.cpp	/^struct CacheFileInfo* try_reuse(struct CacheRef *fileref)$/;"	f
type	cJSON.h	/^    int type;$/;"	m	struct:cJSON
type	dbReplay.cpp	/^	DBTYPE type;$/;"	m	struct:stats_info	file:
type	dbReplay.h	/^	DBTYPE type;$/;"	m	struct:DBInfo
type	traceReplay.h	/^	enum REPLAY_TYPE type;$/;"	m	struct:ReplayJob	typeref:enum:ReplayJob::REPLAY_TYPE
uninstall	traceReplay.cpp	/^	int uninstall;$/;"	m	struct:replay_stat	file:
uninstall_app	traceConfig.h	/^	int uninstall_app;$/;"	m	struct:FullDisk
uninstall_cycle	traceConfig.h	/^	double uninstall_cycle;$/;"	m	struct:NormalApp
uninstall_replayqueue	traceReplay.cpp	/^int uninstall_replayqueue(list<struct ReplayJob*> *ReplayJob_queue, const char *path)$/;"	f
unique_ratio	traceConfig.h	/^	double unique_ratio;$/;"	m	struct:CacheInfo
unique_ratio	traceReplay.h	/^	double unique_ratio;$/;"	m	struct:CacheDirInfo
unlink	simpleReplay.cpp	/^	int unlink;$/;"	m	struct:trace_stat	file:
update	cJSON.cpp	/^static size_t update(const printbuffer *p)$/;"	f	file:
update	traceReplay.cpp	/^	int update;$/;"	m	struct:replay_stat	file:
update_DB	dbReplay.cpp	/^map<string, struct stats_info*> update_DB;$/;"	v
update_cache_file	simpleReplay.cpp	/^static int update_cache_file(struct ReplayJob *arg_replay, string trace_path, string new_path)$/;"	f	file:
update_cycle	traceConfig.h	/^	double update_cycle;$/;"	m	struct:App
update_db_stat	dbReplay.cpp	/^static int update_db_stat(string path, int start_index, int size, string type, int filesize)$/;"	f	file:
update_recent_cache	simpleReplay.cpp	/^static int update_recent_cache(struct CacheDirInfo *cacheDirInfo, string trace_path, long long int filesize)$/;"	f	file:
update_request	dbReplay.cpp	/^static int update_request(string path, long long int offset, long long int write_size, long long int file_size, int type)$/;"	f	file:
update_stats_DB_for_bg	dbReplay.cpp	/^static int update_stats_DB_for_bg(void)$/;"	f	file:
update_stats_DB_for_delete	dbReplay.cpp	/^static int update_stats_DB_for_delete(string path, int delete_type)$/;"	f	file:
update_stats_DB_for_file	dbReplay.cpp	/^static int update_stats_DB_for_file(string path, int fsync)$/;"	f	file:
update_stats_DB_for_tr	dbReplay.cpp	/^static int update_stats_DB_for_tr(string path, int before_size, int after_size, string input_name)$/;"	f	file:
valuedouble	cJSON.h	/^    double valuedouble;$/;"	m	struct:cJSON
valueint	cJSON.h	/^    int valueint;$/;"	m	struct:cJSON
valuestring	cJSON.h	/^    char *valuestring;$/;"	m	struct:cJSON
warm_list	dbReplay.h	/^	vector<int> warm_list;$/;"	m	struct:DBInfo
write_append	simpleReplay.cpp	/^	int write_append;$/;"	m	struct:trace_stat	file:
write_overwrite	simpleReplay.cpp	/^	int write_overwrite;$/;"	m	struct:trace_stat	file:
zipf_slope	traceConfig.h	/^	double zipf_slope;$/;"	m	struct:CacheInfo
zipf_slope	traceReplay.h	/^	double zipf_slope;$/;"	m	struct:CacheDirInfo
